<!doctype html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Solana 验证器（super）</title>
    <style>
        :root {
            --bg: #0b1220;
            --card: #0f1724;
            --muted: #9aa4b2;
            --accent: #00d1b2;
            --glass: rgba(255, 255, 255, 0.03)
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            min-height: 100vh;
            background: linear-gradient(180deg, #071122 0%, #0b1220 100%);
            font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
            color: #e6eef6
        }

        .wrap {
            max-width: 980px;
            margin: 48px auto;
            padding: 28px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
            border-radius: 12px;
            box-shadow: 0 6px 30px rgba(2, 6, 23, 0.6)
        }

        h1 {
            margin: 0 0 6px;
            font-size: 20px
        }

        p.lead {
            margin: 0 0 18px;
            color: var(--muted)
        }

        .form {
            display: flex;
            gap: 12px;
            flex-wrap: wrap
        }

        .field {
            flex: 1 1 220px;
            min-width: 220px
        }

        label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 8px
        }

        input[type=text], input[type=number] {
            width: 100%;
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.04);
            background: var(--card);
            color: inherit
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            border-radius: 10px;
            background: linear-gradient(90deg, var(--accent), #00a88f);
            color: #021217;
            font-weight: 700;
            border: none;
            cursor: pointer
        }

        .btn.secondary {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.04);
            color: var(--muted);
            font-weight: 600
        }

        .controls {
            margin-top: 14px;
            display: flex;
            gap: 10px
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 18px
        }

        th, td {
            padding: 10px 12px;
            text-align: left;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.03)
        }

        th {
            font-size: 12px;
            color: var(--muted)
        }

        td.mult {
            font-weight: 700;
            color: #f3c26b
        }

        .small {
            font-size: 13px;
            color: var(--muted)
        }

        .muted {
            color: var(--muted)
        }

        .hint {
            margin-top: 10px;
            color: var(--muted);
            font-size: 13px
        }

        .copy {
            cursor: pointer;
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.03);
            background: var(--glass);
            font-size: 12px
        }

        @media (max-width: 720px) {
            .form {
                flex-direction: column
            }

            .controls {
                flex-direction: column
            }
        }
    </style>
</head>
<body>
<div class="wrap">
    <h1>Solana 验证器（super）</h1>
    <p class="lead">输入游戏的 签名 / 区块hash 并验证历史结果 —— </p>

    <div class="form" role="form">
        <div class="field">
            <label for="signatureField">签名</label>
            <input id="signatureField" type="text" value="" placeholder="示例: 3f7a..."/>
        </div>

        <div class="field">
            <label for="blockHashField">区块哈希</label>
            <input id="blockHashField" type="text" value="" placeholder="示例: BlockHash 或 Hash123"/>
        </div>

        <div class="field">
            <label for="count">生成数量</label>
            <input id="count" type="number" value="1" min="1" max="100"/>
        </div>
    </div>

    <div class="controls">
        <button id="verifyBtn" class="btn">Verify</button>
        <button id="clearBtn" class="btn secondary">Clear results</button>
        <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
            <span class="small muted">结果格式：</span>
            <span class="small">base58解码签名和区块hash后合并。下个数为最新数的base58编码 → 左边值使用sha-256hash归一化的值即概率</span>
        </div>
    </div>

    <div class="hint">
        注意：。
    </div>

    <table id="resultTable" aria-live="polite">
        <thead>
        <tr>
            <th>Base58</th>
            <th>概率</th>
        </tr>
        </thead>
        <tbody></tbody>
    </table>
</div>
<!--<script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.86.0/lib/index.iife.js"></script>-->
<!--<script src="web3.js"></script>-->
<script type="module">
    //import { PublicKey } from 'https://cdn.jsdelivr.net/npm/@solana/web3.js@1.86.0/lib/index.esm.js';
    import bs58 from "https://cdn.jsdelivr.net/npm/bs58@5.0.0/+esm";
    // const { bs58 } = window.solanaWeb3;


    // var ee=window.solanaWeb3;
    // var ee2=Object.getPrototypeOf(window.solanaWeb3);
    // var ss = window.solanaWeb3.__proto__["bs58$1"];
    // var ss2 = window.solanaWeb3.__proto__["bs58"];
    // var ss3 = window.solanaWeb3.getDefaultExportFromCjs;
    // var ss4 = Object.getOwnPropertyNames(window.solanaWeb3);
    // const decoded = bs58.decode("gggg");

    // helper: utf8 -> hex
    //TODO 加密算法去看签名（好像是base58）,和后端的归一化是否一致，这些TextEncoder的函数
    // 相关如 URLSearchParams 类浏览器是否支持（Chrome，Firefox（fookbook），Safari(苹果)）

    // function buf2hex(buffer) {
    //     return [...new Uint8Array(buffer)].map(b => b.toString(16).padStart(2, '0')).join('')
    // }
    //
    // async function sha256Hex(str) {
    //     const enc = new TextEncoder();
    //     const data = enc.encode(str);
    //     const hash = await crypto.subtle.digest('SHA-256', data);
    //     return buf2hex(hash);
    // }

    //SHA-25 哈希编码函数  这是一个异步函数
    async function hashData(data) {
        // 使用Web Crypto API计算哈希
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        const hashArray = new Uint8Array(hashBuffer);
        return hashArray;
    }

    //base 解码
    // function base58Decode(str) {
    //     const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    //     const base = BigInt(alphabet.length);
    //     let num = BigInt(0);
    //
    //     for (let char of str) {
    //         const index = alphabet.indexOf(char);
    //         if (index < 0) {
    //             throw new Error(`Invalid Base58 character: ${char}`);
    //         }
    //         num = num * base + BigInt(index);
    //     }
    //
    //     // 转换为字节数组
    //     let bytes = [];
    //     while (num > 0) {
    //         bytes.unshift(Number(num % 256n));
    //         num = num / 256n;
    //     }
    //
    //     // 处理前导“1”对应的前导零字节
    //     for (let char of str) {
    //         if (char === '1') bytes.unshift(0);
    //         else break;
    //     }
    //
    //     return new Uint8Array(bytes);
    // }

    // //base58解码
    // // 纯原生 Base58 字母表
    // const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    // const BASE = 58;
    //
    // // Base58 解码
    // function base58Decode(str) {
    //     let bytes = [0];
    //     for (let char of str) {
    //         const value = ALPHABET.indexOf(char);
    //         if (value < 0) throw new Error(`Invalid Base58 character: ${char}`);
    //         let carry = value;
    //         for (let i = 0; i < bytes.length; i++) {
    //             carry += bytes[i] * BASE;
    //             bytes[i] = carry & 0xff;
    //             carry >>= 8;
    //         }
    //         while (carry > 0) {
    //             bytes.push(carry & 0xff);
    //             carry >>= 8;
    //         }
    //     }
    //     // 处理前导零
    //     for (let c of str) {
    //         if (c === '1') bytes.push(0);
    //         else break;
    //     }
    //     return new Uint8Array(bytes.reverse());
    // }

    // 归一化函数（异步，因为 Web Crypto 的 digest 是 Promise）
    async function normalizeHash(decoded) {
        try {
            const hashArray = Array.from(decoded);

            // 2. 转为大整数（BigInt）
            let hashValue = 0n;
            for (const byte of hashArray) {
                hashValue = (hashValue << 8n) + BigInt(byte);
            }

            // 3. 最大值 2^256 - 1
            const maxValue = (1n << 256n) - 1n;

            // 4. 归一化为 [0, 1]
            const normalized = Number(hashValue) / Number(maxValue);
            return normalized;
        } catch (e) {
            console.error(e);
            return 0;
        }
    }

    //归一化函数
    // async function hashDataNormalized(data) {
    //     data = Base58.toSignedArray(Base58.decode(data))
    //     let a = hashData(data)
    //     // let encoder = new TextEncoder();
    //     // let dataBuffer = encoder.encode(data);
    //     // let hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
    //     // let hashArray = Array.from(new Uint8Array(hashBuffer));
    //     //
    //     // // 将哈希视作一个大整数并转为 [0,1) 的浮点数
    //     // let value = 0n;
    //     // for (const byte of hashArray) {
    //     //     value = (value << 8n) + BigInt(byte);
    //     // }
    //     // let max = (1n << BigInt(hashArray.length * 8)) - 1n;
    //     // let normalized = Number(value) / Number(max);
    //     //
    //     // return normalized; // 介于0~1之间的数
    // }

    //转16进制
    // simple deterministic bust conversion: take first 13 hex chars -> int -> map to [1.00, 100.00]
    // function hexToBust(hex) {
    //     // take first 13 chars (52 bits approx)
    //     const slice = hex.slice(0, 13);
    //     const val = parseInt(slice, 16);
    //     // map to multiplier between 1.00 and 100.00
    //     const max = Math.pow(16, 13);
    //     const ratio = val / (max - 1);
    //     const mult = 1 + ratio * 99; // from 1.00 to 100.00
    //     return Math.max(1, Math.floor(mult * 100) / 100).toFixed(2);
    // }

    //随机数=guiyi(sha25(签名+区块hash))
    // function randomValue(hex){
    //     sha256Hex(hex)
    //    return
    // }

    // function getQueryString(name) {
    //     var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');
    //     var r = window.location.search.substr(1).match(reg);
    //     if (r != null) {
    //         return unescape(r[2]);
    //     }
    //     return null;
    // }

    //分割网页传出的参数
    function getQueryString(name) {
        // 转义正则特殊字符，防止注入攻击
        var escapedName = name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        var reg = new RegExp('[?&]' + escapedName + '=([^&]*)', 'i');
        var match = window.location.search.match(reg);
        if (match && match[1]) {
            return match[1];//decodeURIComponent(match[1].replace(/\+/g, ' '));
        }
        return null;
    }

    const signatureEl = document.getElementById('signatureField');
    const blockHashEl = document.getElementById('blockHashField');
    const countEl = document.getElementById('count');
    const verifyBtn = document.getElementById('verifyBtn');
    const clearBtn = document.getElementById('clearBtn');
    const tbody = document.querySelector('#resultTable tbody');

    async function createElementItem(signature, blockHash) {
        verifyBtn.disabled = true;
        verifyBtn.textContent = 'Verifying...';
        tbody.innerHTML = '';
        let count = parseInt(countEl.value) || 1;
        // // 1. 自己实现的Base58 解码
        // const decoded1 = base58Decode(st);
        // const decoded2 = base58Decode(bh);
        //1. bs58 解码
        const decoded1 = bs58.decode(signature);
        const decoded2 = bs58.decode(blockHash);
        // // 1. solanaPublickey 解码
        // const decoded2 = new PublicKey(bh).toBuffer;
        // const decoded1 = new PublicKey(st).toBuffer;
        // === 合并两个字节数组 ===
        let combined = new Uint8Array(decoded1.length + decoded2.length);
        combined.set(decoded1, 0);
        combined.set(decoded2, decoded1.length);
        let base58Value = "";
        for (let i = 0; i < count; i++) {
            combined = await hashData(combined);
            base58Value = bs58.encode(combined)
            const bust = await normalizeHash(combined);
            //加密之后再成为下一个结果

            const tr = document.createElement('tr');
            const td1 = document.createElement('td');
            td1.textContent = base58Value;
            const td2 = document.createElement('td');
            td2.textContent = `${bust}x`;
            td2.className = 'mult';
            tr.appendChild(td1);
            tr.appendChild(td2);
            tbody.appendChild(tr);
        }
        verifyBtn.disabled = false;
        verifyBtn.textContent = 'Verify';
    }

    async function showHash() {
        console.log("hello world")
        // 1. 解析当前 URL 的查询参数
        // const params = new URLSearchParams(window.location.search);
        // 2. 把参数显示出来
        // let result = '';
        // for (const [key, value] of params.entries()) {
        //     result += `${key} = ${value}<br>`;
        // }
        // 3. 输出到页面
        // document.getElementById('output').innerHTML = result || '没有参数';
        // const aa = params.get("aa");
        // signatureEl.value = aa
        signatureEl.value = getQueryString("signature");
        blockHashEl.value = getQueryString("blockHash");
        verifyBtn.click()
    }

    verifyBtn.addEventListener('click', async () => {
        const signatureQuery = signatureEl.value.trim();
        const blockHashQuery = blockHashEl.value.trim();
        if (!signatureQuery) {
            alert('请输入 签名');
            return
        }
        if (!blockHashQuery) {
            alert('请输入 区块hash');
            return
        }
        //let h = gh + salt;
        await createElementItem(signatureQuery, blockHashQuery)
        // for (let i = 0; i < count; i++) {
        //     const input = `${gh}:${salt}:${i}`;
        //     console.log("输入",input,gh,salt,i)
        //     const h = await hashData(input);
        //     const bust = hexToBust(h);
        //     const tr = document.createElement('tr');
        //     const td1 = document.createElement('td');
        //     td1.textContent = h;
        //     const td2 = document.createElement('td');
        //     td2.textContent = `${bust}x`;
        //     td2.className = 'mult';
        //     tr.appendChild(td1);
        //     tr.appendChild(td2);
        //     tbody.appendChild(tr);
        // }
    });

    clearBtn.addEventListener('click', () => {
        tbody.innerHTML = ''
    });
    // convenience: press Enter in any field triggers verify
    [signatureEl, blockHashEl, countEl].forEach(el => el.addEventListener('keydown', e => {
        if (e.key === 'Enter') verifyBtn.click()
    }));
    showHash();

</script>
</body>
</html>
